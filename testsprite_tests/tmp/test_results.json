[
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "2a5ccf6c-9e44-4c40-ae76-376ea8b068e1",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC001-authentication registration and login",
    "description": "Test the user registration and login endpoints to ensure proper validation, role assignment, and pending approval workflow are enforced.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_REGISTER_URL = f\"{BASE_URL}/auth/v1/signup\"\nAUTH_LOGIN_URL = f\"{BASE_URL}/auth/v1/token\"\n\n# The anon/public API key is required in headers for auth requests in Supabase\nAPI_KEY = \"YOUR_SUPABASE_ANON_KEY\"  # Replace this with the actual anon key\nHEADERS_JSON = {\"Content-Type\": \"application/json\", \"apikey\": API_KEY}\nTIMEOUT = 30\n\ndef test_authentication_registration_and_login():\n    # Create a unique email for registration to avoid conflicts\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"StrongPass!23\"\n    role = \"Student\"  # Example role assignment; can be changed as needed\n\n    register_payload = {\n        \"email\": unique_email,\n        \"password\": password,\n        \"options\": {\n            \"data\": {\n                \"role\": role  # role assignment as part of metadata if supported\n            }\n        }\n    }\n\n    token = None\n    try:\n        # Register user\n        reg_response = requests.post(\n            AUTH_REGISTER_URL,\n            json=register_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        assert reg_response.status_code in (200, 201), f\"Registration failed: {reg_response.text}\"\n        reg_data = reg_response.json()\n        # Supabase returns user: {...} and possibly session info or confirmation required\n        assert \"user\" in reg_data, \"Registration response missing 'user'\"\n        assert reg_data[\"user\"][\"email\"] == unique_email, \"Registered email mismatch\"\n        # User should be in pending approval state as per PRD; check if that flag exists\n        # This depends on backend implementation; assume 'confirmed_at' is None for pending approval\n        # or a custom flag in user metadata\n        # Example check: user_metadata.pending_approval == True, else skip\n        user_metadata = reg_data[\"user\"].get(\"user_metadata\", {})\n        pending = user_metadata.get(\"pending_approval\", True)\n        assert pending is True or reg_data[\"user\"].get(\"confirmed_at\") is None, \\\n            \"User should be pending approval after registration\"\n\n        # Attempt login - expect failure or limited access due to pending approval\n        login_payload = {\n            \"grant_type\": \"password\",\n            \"email\": unique_email,\n            \"password\": password\n        }\n        login_response = requests.post(\n            AUTH_LOGIN_URL,\n            data=login_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        # Expect login failure or session with limited scope due to pending approval\n        # Supabase returns 400 with error if not confirmed or allowed\n        if login_response.status_code == 200:\n            login_data = login_response.json()\n            # Check role assignment in user metadata\n            user = login_data.get(\"user\", {})\n            assert user.get(\"email\") == unique_email, \"Login user email mismatch\"\n            # Check role in user_metadata\n            user_role = user.get(\"user_metadata\", {}).get(\"role\")\n            assert user_role == role, f\"User role mismatch: expected {role}, got {user_role}\"\n            # Check if user is flagged for pending approval - still should not allow full access\n            pending_login = user.get(\"user_metadata\", {}).get(\"pending_approval\", True)\n            assert pending_login is True, \"Pending approval flag missing after login\"\n        else:\n            # Expect 400 or 401 due to pending approval; verify error message presence\n            err_data = login_response.json()\n            assert login_response.status_code in (400,401), \"Unexpected login status code\"\n            err_msg = err_data.get(\"error_description\") or err_data.get(\"error\") or \"\"\n            assert err_msg, \"Expected error message for login failure due to pending approval\"\n\n    finally:\n        # Cleanup: Supabase does not provide user deletion via public API easily.\n        # If backend has delete user API endpoint with admin token, use here.\n        # Otherwise, cleanup might be manual or skipped here.\n        pass\n\ntest_authentication_registration_and_login()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 90, in <module>\n  File \"<string>\", line 38, in test_authentication_registration_and_login\nAssertionError: Registration failed: {\"message\":\"Invalid API key\",\"hint\":\"Double check your Supabase `anon` or `service_role` API key.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.825Z",
    "modified": "2025-12-16T13:32:07.202Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "103150e3-643c-40d9-9033-d1928271d7c1",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC002-role based dashboard access",
    "description": "Verify that after login, users are directed to their respective role-based dashboards with correct analytics and quick access features.",
    "code": "import requests\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nTIMEOUT = 30\n\n\ndef test_role_based_dashboard_access():\n    # Test data: users with different roles and their expected dashboard endpoints/features\n    users = [\n        {\n            \"email\": \"admin@example.com\",\n            \"password\": \"AdminPass123!\",\n            \"role\": \"admin\",\n            \"expected_dashboard\": \"/rest/v1/admin_dashboard\",\n        },\n        {\n            \"email\": \"teacher@example.com\",\n            \"password\": \"TeacherPass123!\",\n            \"role\": \"teacher\",\n            \"expected_dashboard\": \"/rest/v1/teacher_dashboard\",\n        },\n        {\n            \"email\": \"student@example.com\",\n            \"password\": \"StudentPass123!\",\n            \"role\": \"student\",\n            \"expected_dashboard\": \"/rest/v1/student_dashboard\",\n        },\n        {\n            \"email\": \"guardian@example.com\",\n            \"password\": \"GuardianPass123!\",\n            \"role\": \"guardian\",\n            \"expected_dashboard\": \"/rest/v1/guardian_dashboard\",\n        },\n    ]\n\n    for user in users:\n        # Authenticate user via Supabase auth endpoint\n        auth_url = f\"{BASE_URL}/auth/v1/token\"\n        auth_headers = {\n            \"Content-Type\": \"application/json\",\n            \"apikey\": \"anon-key\"  # Replace with valid anon/public key if needed\n        }\n        auth_payload = {\n            \"grant_type\": \"password\",\n            \"email\": user[\"email\"],\n            \"password\": user[\"password\"]\n        }\n\n        auth_resp = requests.post(auth_url, json=auth_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert auth_resp.status_code == 200, f\"Login failed for {user['role']} with status {auth_resp.status_code}\"\n        auth_data = auth_resp.json()\n        access_token = auth_data.get(\"access_token\")\n        assert access_token, f\"Access token missing for {user['role']}\"\n\n        # Use access token to get role from user metadata/session or via user endpoint\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"apikey\": \"anon-key\",\n        }\n\n        # Verify role from /rest/v1/users endpoint with RLS enabled\n        user_resp = requests.get(f\"{BASE_URL}/rest/v1/users?email=eq.{user['email']}\", headers=headers, timeout=TIMEOUT)\n        assert user_resp.status_code == 200, f\"Could not fetch user info for {user['role']}\"\n        user_info = user_resp.json()\n        assert len(user_info) == 1, f\"Unexpected user info length for {user['role']}\"\n        db_role = user_info[0].get(\"role\") or user_info[0].get(\"user_role\")  # depending on schema naming\n        assert db_role == user[\"role\"], f\"User role mismatch for {user['role']} expected: {user['role']} got: {db_role}\"\n\n        # Access role-based dashboard endpoint to verify access and data correctness\n        dashboard_url = f\"{BASE_URL}{user['expected_dashboard']}\"\n        dashboard_resp = requests.get(dashboard_url, headers=headers, timeout=TIMEOUT)\n        assert dashboard_resp.status_code == 200, f\"Dashboard access failed for {user['role']}\"\n\n        dashboard_data = dashboard_resp.json()\n        # Basic assertions to verify analytics and quick access features presence in dashboard\n        assert isinstance(dashboard_data, dict), \"Dashboard data is not a dictionary\"\n        assert \"analytics\" in dashboard_data, f\"Analytics missing in {user['role']} dashboard\"\n        assert \"quick_access\" in dashboard_data, f\"Quick access features missing in {user['role']} dashboard\"\n        # Further detailed feature checks can be made here as needed\n\n\ntest_role_based_dashboard_access()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 82, in <module>\n  File \"<string>\", line 50, in test_role_based_dashboard_access\nAssertionError: Login failed for admin with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.831Z",
    "modified": "2025-12-16T13:32:11.154Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "7818e7b9-2ed8-40f5-80d8-26fb22b86b48",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC003-course creation and management",
    "description": "Test course creation, editing, module and material management APIs to ensure only authorized users can perform these actions and data is saved correctly.",
    "code": "import requests\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nAPI_URL = f\"{BASE_URL}/rest/v1\"\nTIMEOUT = 30\n\n# Admin user credentials for authentication to perform course management actions\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\n\ndef authenticate(email, password):\n    \"\"\"Authenticate user via Supabase Auth and return access token.\"\"\"\n    resp = requests.post(\n        f\"{AUTH_URL}/token\",\n        data={\"grant_type\": \"password\", \"email\": email, \"password\": password},\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\", \"apikey\": \"anon-key\"},\n        timeout=TIMEOUT\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data\n    assert data.get(\"token_type\") == \"bearer\"\n    return data[\"access_token\"]\n\n\ndef test_course_creation_and_management():\n    access_token = authenticate(ADMIN_EMAIL, ADMIN_PASSWORD)\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"apikey\": \"anon-key\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    course_id = None\n    module_id = None\n    material_id = None\n\n    try:\n        # 1. Create a new course\n        course_payload = {\n            \"title\": \"Test Course API\",\n            \"description\": \"Course created during automated test for management.\",\n            \"published\": False\n        }\n        resp = requests.post(\n            f\"{API_URL}/courses\",\n            headers=headers,\n            json=course_payload,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201 or resp.status_code == 200\n        course = resp.json()\n        assert isinstance(course, list) and len(course) == 1\n        course_id = course[0][\"id\"]\n        assert course[0][\"title\"] == course_payload[\"title\"]\n\n        # 2. Edit the created course\n        update_payload = {\n            \"description\": \"Updated course description by automated test.\"\n        }\n        resp = requests.patch(\n            f\"{API_URL}/courses?id=eq.{course_id}\",\n            headers=headers,\n            json=update_payload,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200\n        updated_course = resp.json()\n        assert isinstance(updated_course, list) and len(updated_course) == 1\n        assert updated_course[0][\"description\"] == update_payload[\"description\"]\n\n        # 3. Create a module for the course\n        module_payload = {\n            \"course_id\": course_id,\n            \"title\": \"Introduction Module\",\n            \"description\": \"Module created for automated test\"\n        }\n        resp = requests.post(\n            f\"{API_URL}/modules\",\n            headers=headers,\n            json=module_payload,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201 or resp.status_code == 200\n        modules = resp.json()\n        assert isinstance(modules, list) and len(modules) == 1\n        module_id = modules[0][\"id\"]\n        assert modules[0][\"title\"] == module_payload[\"title\"]\n        assert modules[0][\"course_id\"] == course_id\n\n        # 4. Edit the created module\n        module_update = {\n            \"description\": \"Updated module description by automated test\"\n        }\n        resp = requests.patch(\n            f\"{API_URL}/modules?id=eq.{module_id}\",\n            headers=headers,\n            json=module_update,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200\n        updated_module = resp.json()\n        assert isinstance(updated_module, list) and len(updated_module) == 1\n        assert updated_module[0][\"description\"] == module_update[\"description\"]\n\n        # 5. Add material to the module\n        material_payload = {\n            \"module_id\": module_id,\n            \"title\": \"Test Material\",\n            \"type\": \"video\",\n            \"content_url\": \"https://example.com/video.mp4\"\n        }\n        resp = requests.post(\n            f\"{API_URL}/materials\",\n            headers=headers,\n            json=material_payload,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201 or resp.status_code == 200\n        materials = resp.json()\n        assert isinstance(materials, list) and len(materials) == 1\n        material_id = materials[0][\"id\"]\n        assert materials[0][\"title\"] == material_payload[\"title\"]\n        assert materials[0][\"type\"] == material_payload[\"type\"]\n\n        # 6. Edit the material\n        material_update = {\n            \"title\": \"Updated Test Material\",\n            \"content_url\": \"https://example.com/updated-video.mp4\"\n        }\n        resp = requests.patch(\n            f\"{API_URL}/materials?id=eq.{material_id}\",\n            headers=headers,\n            json=material_update,\n            params={\"return\": \"representation\"},\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200\n        updated_material = resp.json()\n        assert isinstance(updated_material, list) and len(updated_material) == 1\n        assert updated_material[0][\"title\"] == material_update[\"title\"]\n\n        # 7. Test unauthorized access: try creating a course without token\n        resp = requests.post(\n            f\"{API_URL}/courses\",\n            headers={\"apikey\": \"anon-key\", \"Content-Type\": \"application/json\"},\n            json=course_payload,\n            timeout=TIMEOUT\n        )\n        # Should be unauthorized or forbidden\n        assert resp.status_code in (401, 403)\n\n    finally:\n        # Cleanup created resources in reverse order\n        if material_id:\n            resp = requests.delete(\n                f\"{API_URL}/materials?id=eq.{material_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code in (204, 200, 202, 404)  # 404 means already deleted\n\n        if module_id:\n            resp = requests.delete(\n                f\"{API_URL}/modules?id=eq.{module_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code in (204, 200, 202, 404)\n\n        if course_id:\n            resp = requests.delete(\n                f\"{API_URL}/courses?id=eq.{course_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code in (204, 200, 202, 404)\n\n\ntest_course_creation_and_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 29, in test_course_creation_and_management\n  File \"<string>\", line 21, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://pcpiigyuafdzgokiosve.supabase.co/auth/v1/token\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.837Z",
    "modified": "2025-12-16T13:32:54.346Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "98cfd11b-f5f6-48a0-90e3-7f2b77a7e493",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC004-student enrollment in courses",
    "description": "Validate student enrollment endpoints including self-enrollment, bulk enrollment, and admin-driven enrollment with proper role and policy checks.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nREST_URL = f\"{BASE_URL}/rest/v1\"\nTIMEOUT = 30\n\n# These credentials and tokens would typically be securely managed or obtained dynamically.\n# For this test, we assume existence of users with roles: student, admin, and teacher.\n\n# Placeholder credentials (would be replaced with valid test users on the system).\nCREDENTIALS = {\n    \"student\": {\"email\": \"student@example.com\", \"password\": \"password123\"},\n    \"admin\": {\"email\": \"admin@example.com\", \"password\": \"password123\"},\n    \"teacher\": {\"email\": \"teacher@example.com\", \"password\": \"password123\"},\n}\n\ndef login(email, password):\n    resp = requests.post(\n        f\"{AUTH_URL}/token\",\n        json={\"email\": email, \"password\": password},\n        headers={\"Content-Type\": \"application/json\"},\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data and data[\"access_token\"], \"Login failed: access_token missing\"\n    return data[\"access_token\"], data.get(\"refresh_token\")\n\ndef create_course(admin_access_token):\n    course_id = str(uuid.uuid4())\n    course_payload = {\n        \"id\": course_id,\n        \"title\": f\"Test Course {course_id}\",\n        \"description\": \"Test course for enrollment API\",\n        \"published\": False\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {admin_access_token}\",\n        \"Content-Type\": \"application/json\",\n        \"Prefer\": \"return=representation\"\n    }\n    resp = requests.post(\n        f\"{REST_URL}/courses\",\n        json=course_payload,\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    created = resp.json()\n    assert isinstance(created, list) and len(created) == 1 and created[0][\"id\"] == course_id\n    return course_id\n\ndef delete_course(course_id, admin_access_token):\n    headers = {\"Authorization\": f\"Bearer {admin_access_token}\"}\n    resp = requests.delete(\n        f\"{REST_URL}/courses?id=eq.{course_id}\",\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    # No content or empty array expected on deletion\n    assert resp.status_code in (200, 204)\n\ndef create_user(role, admin_access_token):\n    # Create a user with given role, returns user id and email\n    user_id = str(uuid.uuid4())\n    user_email = f\"{role}_{user_id[:8]}@example.com\"\n    user_payload = {\n        \"id\": user_id,\n        \"email\": user_email,\n        \"role\": role,\n        \"password\": \"password123\",\n        \"confirmed_at\": \"2025-01-01T00:00:00Z\",\n        \"email_confirmed_at\": \"2025-01-01T00:00:00Z\"\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {admin_access_token}\",\n        \"Content-Type\": \"application/json\",\n        \"Prefer\": \"return=representation\"\n    }\n    resp = requests.post(\n        f\"{REST_URL}/users\",\n        json=user_payload,\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    created = resp.json()\n    assert isinstance(created, list) and len(created) == 1 and created[0][\"id\"] == user_id\n    return user_id, user_email\n\ndef delete_user(user_id, admin_access_token):\n    headers = {\"Authorization\": f\"Bearer {admin_access_token}\"}\n    resp = requests.delete(\n        f\"{REST_URL}/users?id=eq.{user_id}\",\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    assert resp.status_code in (200, 204)\n\ndef enroll_student_self(course_id, student_token):\n    headers = {\"Authorization\": f\"Bearer {student_token}\", \"Content-Type\": \"application/json\"}\n    enrollment_payload = {\"course_id\": course_id}\n    resp = requests.post(\n        f\"{REST_URL}/enrollments\",\n        json=enrollment_payload,\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    return resp\n\ndef enroll_students_bulk(course_id, student_ids, admin_token):\n    headers = {\"Authorization\": f\"Bearer {admin_token}\", \"Content-Type\": \"application/json\"}\n    enrollments = [{\"course_id\": course_id, \"user_id\": uid} for uid in student_ids]\n    resp = requests.post(\n        f\"{REST_URL}/enrollments/bulk\",\n        json={\"enrollments\": enrollments},\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    return resp\n\ndef admin_enroll_student(course_id, user_id, admin_token):\n    headers = {\"Authorization\": f\"Bearer {admin_token}\", \"Content-Type\": \"application/json\"}\n    enrollment_payload = {\"course_id\": course_id, \"user_id\": user_id}\n    resp = requests.post(\n        f\"{REST_URL}/enrollments/admin_enroll\",\n        json=enrollment_payload,\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    return resp\n\ndef get_enrollments(course_id, token):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.get(\n        f\"{REST_URL}/enrollments?course_id=eq.{course_id}\",\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    return resp.json()\n\ndef test_student_enrollment_in_courses():\n    # Log in as admin to create course and users\n    admin_token, _ = login(CREDENTIALS[\"admin\"][\"email\"], CREDENTIALS[\"admin\"][\"password\"])\n\n    # Create a test course\n    course_id = create_course(admin_token)\n\n    # Create a new student user for self-enrollment test\n    student_id, student_email = None, None\n    # Create second student for bulk enrollment test\n    student2_id, student2_email = None, None\n    try:\n        student_id, student_email = create_user(\"student\", admin_token)\n        student2_id, student2_email = create_user(\"student\", admin_token)\n\n        # Login as student to get token for self-enrollment\n        student_token, _ = login(student_email, \"password123\")\n\n        # 1) Self-enrollment test by student\n        resp = enroll_student_self(course_id, student_token)\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Self-enrollment failed: {resp.text}\"\n        enrollment_data = resp.json()\n        assert isinstance(enrollment_data, list) and any(e[\"course_id\"] == course_id for e in enrollment_data), \"Enrollment data missing or incorrect\"\n\n        # 2) Bulk enrollment test by admin\n        bulk_resp = enroll_students_bulk(course_id, [student_id, student2_id], admin_token)\n        assert bulk_resp.status_code == 200 or bulk_resp.status_code == 201, f\"Bulk enrollment failed: {bulk_resp.text}\"\n        bulk_data = bulk_resp.json()\n        assert isinstance(bulk_data, list), \"Bulk enrollment response not a list\"\n        enrolled_user_ids = {enr[\"user_id\"] for enr in bulk_data}\n        assert student_id in enrolled_user_ids and student2_id in enrolled_user_ids, \"Bulk enrollment missing users\"\n\n        # 3) Admin-driven enrollment of a new student user\n        # Create a third student user to enrol by admin\n        student3_id, student3_email = create_user(\"student\", admin_token)\n        admin_enroll_resp = admin_enroll_student(course_id, student3_id, admin_token)\n        assert admin_enroll_resp.status_code == 201 or admin_enroll_resp.status_code == 200, f\"Admin enroll failed: {admin_enroll_resp.text}\"\n        admin_enroll_data = admin_enroll_resp.json()\n        assert isinstance(admin_enroll_data, list) and any(e[\"user_id\"] == student3_id for e in admin_enroll_data), \"Admin enrollment data missing or incorrect\"\n\n        # 4) Verify enrollments with admin token (should see all)\n        all_enrollments = get_enrollments(course_id, admin_token)\n        enrolled_ids = {e[\"user_id\"] for e in all_enrollments}\n        assert student_id in enrolled_ids and student2_id in enrolled_ids and student3_id in enrolled_ids, \"Enrollments verification failed\"\n\n        # 5) Role and policy checks: Try enrolling with a teacher token (should fail)\n        teacher_token, _ = login(CREDENTIALS[\"teacher\"][\"email\"], CREDENTIALS[\"teacher\"][\"password\"])\n        teacher_enroll_resp = enroll_student_self(course_id, teacher_token)\n        assert teacher_enroll_resp.status_code in (401, 403), f\"Teacher should not be able to self-enroll as student: {teacher_enroll_resp.status_code}\"\n\n        # 6) Attempt unenrolled user enrollment without proper role (simulate guardian)\n        guardian_id, guardian_email = create_user(\"guardian\", admin_token)\n        guardian_token, _ = login(guardian_email, \"password123\")\n        guardian_enroll_resp = enroll_student_self(course_id, guardian_token)\n        assert guardian_enroll_resp.status_code in (401, 403), f\"Guardian should not be able to self-enroll: {guardian_enroll_resp.status_code}\"\n\n        # Clean up guardian user after testing\n        delete_user(guardian_id, admin_token)\n\n        # 7) Negative test: unauthenticated enrollment attempt\n        unauth_resp = requests.post(\n            f\"{REST_URL}/enrollments\",\n            json={\"course_id\": course_id},\n            headers={\"Content-Type\": \"application/json\"},\n            timeout=TIMEOUT,\n        )\n        assert unauth_resp.status_code == 401, f\"Unauthenticated enrollment request not denied: {unauth_resp.status_code}\"\n\n    finally:\n        # Cleanup created users and course\n        if student_id:\n            try:\n                delete_user(student_id, admin_token)\n            except Exception:\n                pass\n        if student2_id:\n            try:\n                delete_user(student2_id, admin_token)\n            except Exception:\n                pass\n        if 'student3_id' in locals() and student3_id:\n            try:\n                delete_user(student3_id, admin_token)\n            except Exception:\n                pass\n        try:\n            delete_course(course_id, admin_token)\n        except Exception:\n            pass\n\ntest_student_enrollment_in_courses()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 237, in <module>\n  File \"<string>\", line 149, in test_student_enrollment_in_courses\n  File \"<string>\", line 26, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://pcpiigyuafdzgokiosve.supabase.co/auth/v1/token\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.843Z",
    "modified": "2025-12-16T13:31:46.296Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "45998c2b-c511-42e7-826e-ee5baaa0e794",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC005-library content upload and management",
    "description": "Test the content library APIs for uploading, viewing, and managing PDF and video content ensuring only authorized roles can perform these actions.",
    "code": "import requests\nimport uuid\nimport os\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nREST_URL = f\"{BASE_URL}/rest/v1\"\nSTORAGE_URL = f\"{BASE_URL}/storage/v1\"\n\n# Test admin user credentials (assumed to exist and authorized for library content management)\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\nSUPABASE_ANON_KEY = os.getenv(\"SUPABASE_ANON_KEY\")\nassert SUPABASE_ANON_KEY, \"SUPABASE_ANON_KEY environment variable must be set\"\n\ndef test_library_content_upload_and_management():\n    \"\"\"\n    Test the content library APIs for uploading, viewing, and managing PDF and video content ensuring only authorized roles can perform these actions.\n    \"\"\"\n\n    headers_auth = {\n        \"Content-Type\": \"application/json\",\n        \"apikey\": SUPABASE_ANON_KEY\n    }\n    session = requests.Session()\n\n    # Authenticate as Admin to get access token\n    auth_resp = session.post(\n        f\"{AUTH_URL}/token\",\n        headers=headers_auth,\n        json={\"email\": ADMIN_EMAIL, \"password\": ADMIN_PASSWORD},\n        timeout=30,\n    )\n    assert auth_resp.status_code == 200, f\"Auth failed: {auth_resp.text}\"\n\n    auth_data = auth_resp.json()\n    access_token = auth_data.get(\"access_token\")\n    assert access_token, \"No access token returned\"\n\n    # Common headers with authorization for subsequent REST and Storage calls\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"apikey\": SUPABASE_ANON_KEY,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    # --- Step 1: Upload PDF file to storage\n    bucket_id = \"library-content\"\n    pdf_file_content = b\"%PDF-1.4 test pdf content\"  # minimal PDF header content as dummy file\n    # Generate unique file key\n    pdf_file_key = f\"test_uploads/{uuid.uuid4()}.pdf\"\n\n    # Upload PDF via Storage API (POST to /object/{bucket}/path)\n    upload_pdf_resp = session.post(\n        f\"{STORAGE_URL}/object/{bucket_id}/{pdf_file_key}\",\n        headers={\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/pdf\",\n        },\n        data=pdf_file_content,\n        timeout=30,\n    )\n    assert upload_pdf_resp.status_code in (200, 201), f\"PDF upload failed: {upload_pdf_resp.text}\"\n\n    # --- Step 2: Upload Video file to storage\n    video_file_content = b\"\\x00\\x00\\x00\\x18ftypmp42\"  # minimal mp4 header as dummy file\n    video_file_key = f\"test_uploads/{uuid.uuid4()}.mp4\"\n\n    upload_video_resp = session.post(\n        f\"{STORAGE_URL}/object/{bucket_id}/{video_file_key}\",\n        headers={\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"video/mp4\",\n        },\n        data=video_file_content,\n        timeout=30,\n    )\n    assert upload_video_resp.status_code in (200, 201), f\"Video upload failed: {upload_video_resp.text}\"\n\n    # --- Step 3: Insert metadata for PDF into Postgres table (library contents)\n    library_table = \"library_contents\"\n\n    pdf_metadata = {\n        \"title\": \"Test PDF Document\",\n        \"content_type\": \"pdf\",\n        \"storage_path\": pdf_file_key,\n        \"description\": \"Test PDF upload for automated test\",\n    }\n    # Insert PDF metadata\n    insert_pdf_resp = session.post(\n        f\"{REST_URL}/{library_table}\",\n        headers=headers,\n        json=pdf_metadata,\n        timeout=30,\n    )\n    assert insert_pdf_resp.status_code == 201, f\"Insert PDF metadata failed: {insert_pdf_resp.text}\"\n    pdf_entry = insert_pdf_resp.json()\n    pdf_id = pdf_entry.get(\"id\")\n    assert pdf_id, \"No ID returned for PDF entry\"\n\n    # --- Step 4: Insert metadata for Video into Postgres table\n    video_metadata = {\n        \"title\": \"Test Video Content\",\n        \"content_type\": \"video\",\n        \"storage_path\": video_file_key,\n        \"description\": \"Test video upload for automated test\",\n    }\n    insert_video_resp = session.post(\n        f\"{REST_URL}/{library_table}\",\n        headers=headers,\n        json=video_metadata,\n        timeout=30,\n    )\n    assert insert_video_resp.status_code == 201, f\"Insert Video metadata failed: {insert_video_resp.text}\"\n    video_entry = insert_video_resp.json()\n    video_id = video_entry.get(\"id\")\n    assert video_id, \"No ID returned for Video entry\"\n\n    try:\n        # --- Step 5: View uploaded PDF content metadata via GET\n        get_pdf_resp = session.get(\n            f\"{REST_URL}/{library_table}?id=eq.{pdf_id}\",\n            headers=headers,\n            timeout=30,\n        )\n        assert get_pdf_resp.status_code == 200, f\"Get PDF metadata failed: {get_pdf_resp.text}\"\n        pdf_contents = get_pdf_resp.json()\n        assert len(pdf_contents) == 1, \"PDF metadata not found\"\n        assert pdf_contents[0][\"content_type\"] == \"pdf\", \"Content type mismatch for PDF\"\n\n        # --- Step 6: View uploaded Video content metadata via GET\n        get_video_resp = session.get(\n            f\"{REST_URL}/{library_table}?id=eq.{video_id}\",\n            headers=headers,\n            timeout=30,\n        )\n        assert get_video_resp.status_code == 200, f\"Get Video metadata failed: {get_video_resp.text}\"\n        video_contents = get_video_resp.json()\n        assert len(video_contents) == 1, \"Video metadata not found\"\n        assert video_contents[0][\"content_type\"] == \"video\", \"Content type mismatch for Video\"\n\n        # --- Step 7: Update PDF content metadata (description change)\n        updated_description = \"Updated PDF description for test\"\n        update_pdf_resp = session.patch(\n            f\"{REST_URL}/{library_table}?id=eq.{pdf_id}\",\n            headers=headers,\n            json={\"description\": updated_description},\n            timeout=30,\n        )\n        assert update_pdf_resp.status_code in (200, 204), f\"Update PDF metadata failed: {update_pdf_resp.text}\"\n\n        # Verify update\n        verify_pdf_resp = session.get(\n            f\"{REST_URL}/{library_table}?id=eq.{pdf_id}\",\n            headers=headers,\n            timeout=30,\n        )\n        assert verify_pdf_resp.status_code == 200, f\"Verify PDF update failed: {verify_pdf_resp.text}\"\n        verify_pdf = verify_pdf_resp.json()\n        assert verify_pdf[0][\"description\"] == updated_description, \"PDF description update unsuccessful\"\n\n        # --- Step 8: Attempt unauthorized action as non-authorized role (simulate)\n        # For this test, we'll attempt with an invalid token to simulate unauthorized user\n        unauthorized_headers = {\n            \"Authorization\": \"Bearer invalidtoken\",\n            \"apikey\": SUPABASE_ANON_KEY,\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        }\n        unauthorized_resp = session.post(\n            f\"{REST_URL}/{library_table}\",\n            headers=unauthorized_headers,\n            json={\n                \"title\": \"Unauthorized Upload\",\n                \"content_type\": \"pdf\",\n                \"storage_path\": \"some/path.pdf\",\n            },\n            timeout=30,\n        )\n        assert unauthorized_resp.status_code in (401, 403), \"Unauthorized upload should be rejected\"\n\n    finally:\n        # Cleanup inserted entries and uploaded files\n\n        # Delete PDF metadata entry\n        del_pdf_meta = session.delete(\n            f\"{REST_URL}/{library_table}?id=eq.{pdf_id}\",\n            headers=headers,\n            timeout=30,\n        )\n        assert del_pdf_meta.status_code in (200, 204), f\"Failed to delete PDF metadata: {del_pdf_meta.text}\"\n\n        # Delete video metadata entry\n        del_video_meta = session.delete(\n            f\"{REST_URL}/{library_table}?id=eq.{video_id}\",\n            headers=headers,\n            timeout=30,\n        )\n        assert del_video_meta.status_code in (200, 204), f\"Failed to delete video metadata: {del_video_meta.text}\"\n\n        # Delete uploaded PDF file\n        del_pdf_file = session.delete(\n            f\"{STORAGE_URL}/object/{bucket_id}/{pdf_file_key}\",\n            headers={\"Authorization\": f\"Bearer {access_token}\"},\n            timeout=30,\n        )\n        assert del_pdf_file.status_code in (200, 204), f\"Failed to delete PDF file: {del_pdf_file.text}\"\n\n        # Delete uploaded Video file\n        del_video_file = session.delete(\n            f\"{STORAGE_URL}/object/{bucket_id}/{video_file_key}\",\n            headers={\"Authorization\": f\"Bearer {access_token}\"},\n            timeout=30,\n        )\n        assert del_video_file.status_code in (200, 204), f\"Failed to delete video file: {del_video_file.text}\"\n\ntest_library_content_upload_and_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 15, in <module>\nAssertionError: SUPABASE_ANON_KEY environment variable must be set\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.848Z",
    "modified": "2025-12-16T13:33:05.117Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "02efc2d8-e415-43d4-91eb-3259fb851d1a",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC006-assignment creation submission and grading",
    "description": "Verify assignment system endpoints for creation by teachers, submission by students, and grading with role-based access and state management.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nTIMEOUT = 30\n\n# Example users for authentication\nUSERS = {\n    \"teacher\": {\"email\": \"teacher@example.com\", \"password\": \"TeacherPass123!\"},\n    \"student\": {\"email\": \"student@example.com\", \"password\": \"StudentPass123!\"},\n}\n\ndef supabase_sign_in(email: str, password: str):\n    url = f\"{BASE_URL}/auth/v1/token?grant_type=password\"\n    headers = {\"Content-Type\": \"application/json\"}\n    payload = {\"email\": email, \"password\": password}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data\n    return data[\"access_token\"]\n\ndef create_assignment(token, course_id):\n    url = f\"{BASE_URL}/rest/v1/assignments\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    assignment_id = str(uuid.uuid4())\n    assignment_payload = {\n        \"id\": assignment_id,\n        \"course_id\": course_id,\n        \"title\": \"Test Assignment\",\n        \"description\": \"Assignment created during test\",\n        \"due_date\": \"2030-12-31T23:59:59Z\",\n        \"status\": \"created\"\n    }\n    resp = requests.post(url, json=assignment_payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 201 or resp.status_code == 200\n    created = resp.json()\n    assert created[\"id\"] == assignment_id\n    return created\n\ndef submit_assignment(token, assignment_id):\n    url = f\"{BASE_URL}/rest/v1/assignment_submissions\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    submission_id = str(uuid.uuid4())\n    submission_payload = {\n        \"id\": submission_id,\n        \"assignment_id\": assignment_id,\n        \"content\": \"Answer contents for the assignment.\",\n        \"status\": \"submitted\"\n    }\n    resp = requests.post(url, json=submission_payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 201 or resp.status_code == 200\n    submitted = resp.json()\n    assert submitted[\"id\"] == submission_id\n    return submitted\n\ndef grade_assignment(token, submission_id, grade_value=95):\n    url = f\"{BASE_URL}/rest/v1/assignment_submissions?id=eq.{submission_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    grade_payload = {\n        \"grade\": grade_value,\n        \"status\": \"graded\",\n        \"feedback\": \"Good job on the assignment.\"\n    }\n    resp = requests.patch(url, json=grade_payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 204\n    # Fetch updated submission to verify grading\n    get_resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    get_resp.raise_for_status()\n    submissions = get_resp.json()\n    assert len(submissions) == 1\n    submission = submissions[0]\n    assert submission[\"grade\"] == grade_value\n    assert submission[\"status\"] == \"graded\"\n    return submission\n\ndef delete_assignment(token, assignment_id):\n    url = f\"{BASE_URL}/rest/v1/assignments?id=eq.{assignment_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Accept\": \"application/json\"\n    }\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 204\n\ndef delete_submission(token, submission_id):\n    url = f\"{BASE_URL}/rest/v1/assignment_submissions?id=eq.{submission_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Accept\": \"application/json\"\n    }\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 204\n\ndef test_assignment_creation_submission_and_grading():\n    # Sign in users to get tokens\n    teacher_token = supabase_sign_in(USERS[\"teacher\"][\"email\"], USERS[\"teacher\"][\"password\"])\n    student_token = supabase_sign_in(USERS[\"student\"][\"email\"], USERS[\"student\"][\"password\"])\n\n    # We need a valid course_id for assignment - create a temp course or query one\n    # For test, we try to get one course id from teacher-accessible courses\n    courses_url = f\"{BASE_URL}/rest/v1/courses\"\n    headers_teacher = {\n        \"Authorization\": f\"Bearer {teacher_token}\",\n        \"apikey\": teacher_token,\n        \"Accept\": \"application/json\"\n    }\n    resp_courses = requests.get(courses_url, headers=headers_teacher, timeout=TIMEOUT)\n    resp_courses.raise_for_status()\n    courses = resp_courses.json()\n    assert isinstance(courses, list) and len(courses) > 0\n    course_id = courses[0][\"id\"]\n\n    assignment = None\n    submission = None\n\n    try:\n        # Teacher creates assignment\n        assignment = create_assignment(teacher_token, course_id)\n\n        # Student submits assignment\n        submission = submit_assignment(student_token, assignment[\"id\"])\n\n        # Teacher grades submission\n        graded = grade_assignment(teacher_token, submission[\"id\"], grade_value=88)\n\n        # Validate role-based access control:\n        # Student attempting to create assignment should be forbidden (403)\n        url = f\"{BASE_URL}/rest/v1/assignments\"\n        headers_student = {\n            \"Authorization\": f\"Bearer {student_token}\",\n            \"apikey\": student_token,\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\"\n        }\n        payload = {\n            \"id\": str(uuid.uuid4()),\n            \"course_id\": course_id,\n            \"title\": \"Invalid creation by student\",\n            \"description\": \"Should not be allowed\",\n            \"due_date\": \"2030-01-01T12:00:00Z\",\n            \"status\": \"created\"\n        }\n        resp = requests.post(url, json=payload, headers=headers_student, timeout=TIMEOUT)\n        assert resp.status_code in (401, 403)\n\n        # Student trying to grade a submission should be forbidden (403)\n        patch_url = f\"{BASE_URL}/rest/v1/assignment_submissions?id=eq.{submission['id']}\"\n        grade_payload = {\n            \"grade\": 50,\n            \"status\": \"graded\",\n            \"feedback\": \"Invalid grade attempt\"\n        }\n        resp = requests.patch(patch_url, json=grade_payload, headers=headers_student, timeout=TIMEOUT)\n        assert resp.status_code in (401, 403)\n\n    finally:\n        # Cleanup: delete submission and assignment if created\n        if submission:\n            try:\n                delete_submission(teacher_token, submission[\"id\"])\n            except Exception:\n                pass\n        if assignment:\n            try:\n                delete_assignment(teacher_token, assignment[\"id\"])\n            except Exception:\n                pass\n\ntest_assignment_creation_submission_and_grading()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 192, in <module>\n  File \"<string>\", line 119, in test_assignment_creation_submission_and_grading\n  File \"<string>\", line 18, in supabase_sign_in\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://pcpiigyuafdzgokiosve.supabase.co/auth/v1/token?grant_type=password\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.853Z",
    "modified": "2025-12-16T13:31:43.493Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "fd62cfd6-1e1c-4111-a503-b1ce33268766",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC007-user management and role assignment",
    "description": "Test user CRUD operations, role assignments, and permission management APIs to ensure only admins can modify user roles and permissions.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nREST_URL = f\"{BASE_URL}/rest/v1\"\nTIMEOUT = 30\n\n# Admin user credentials (should be replaced with valid test admin credentials)\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\ndef get_auth_token(email, password):\n    \"\"\"Authenticate user and return access token\"\"\"\n    resp = requests.post(\n        f\"{AUTH_URL}/token\",\n        data={\"grant_type\": \"password\", \"email\": email, \"password\": password},\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data, \"No access_token in login response\"\n    return data[\"access_token\"], data.get(\"user\", {}).get(\"id\")\n\ndef create_user(admin_token, user_email):\n    \"\"\"Create a new user via Supabase auth admin endpoint\"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {admin_token}\",\n        \"apikey\": admin_token,\n        \"Content-Type\": \"application/json\",\n        \"Prefer\": \"return=representation\"\n    }\n    payload = {\n        \"email\": user_email,\n        \"password\": \"TestUserPass123!\",\n        \"email_confirmed\": True\n    }\n    resp = requests.post(\n        f\"{AUTH_URL}/admin/users\",\n        json=payload,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    resp.raise_for_status()\n    user = resp.json()\n    assert \"id\" in user, \"No user ID returned creating user\"\n    return user[\"id\"]\n\ndef delete_user(admin_token, user_id):\n    \"\"\"Delete user via Supabase auth admin endpoint\"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {admin_token}\",\n        \"apikey\": admin_token\n    }\n    resp = requests.delete(\n        f\"{AUTH_URL}/admin/users/{user_id}\",\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    # 204 No Content expected\n    assert resp.status_code == 204\n\ndef supabase_rest_request(token, method, path, json_data=None):\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"apikey\": token,\n        \"Content-Type\": \"application/json\",\n        \"Prefer\": \"return=representation\"\n    }\n    url = f\"{REST_URL}/{path}\"\n    resp = requests.request(method, url, headers=headers, json=json_data, timeout=TIMEOUT)\n    return resp\n\ndef test_user_management_and_role_assignment():\n    # 1. Authenticate as admin\n    admin_token, admin_user_id = get_auth_token(ADMIN_EMAIL, ADMIN_PASSWORD)\n\n    # 2. Create a new user to manage\n    new_email = f\"user_{uuid.uuid4().hex[:8]}@example.com\"\n    user_id = None\n    try:\n        user_id = create_user(admin_token, new_email)\n\n        # 3. Verify read user details operation as admin\n        resp = supabase_rest_request(admin_token, \"GET\", f\"users?id=eq.{user_id}\")\n        assert resp.status_code == 200\n        users = resp.json()\n        assert len(users) == 1\n        assert users[0][\"id\"] == user_id\n        assert users[0][\"email\"] == new_email\n\n        # 4. Update user info as admin (e.g. update full_name)\n        update_payload = {\"full_name\": \"Test User Updated\"}\n        resp = supabase_rest_request(admin_token, \"PATCH\", f\"users?id=eq.{user_id}\", update_payload)\n        assert resp.status_code == 200\n        updated_users = resp.json()\n        assert len(updated_users) == 1\n        assert updated_users[0][\"full_name\"] == \"Test User Updated\"\n\n        # 5. Assign a role to the user as admin\n        # Assuming there's a user_roles table with user_id and role columns\n        role_payload = {\"user_id\": user_id, \"role\": \"teacher\"}\n        resp = supabase_rest_request(admin_token, \"POST\", \"user_roles\", role_payload)\n        assert resp.status_code == 201\n        created_role = resp.json()\n        assert created_role[0][\"user_id\"] == user_id\n        assert created_role[0][\"role\"] == \"teacher\"\n\n        # 6. Attempt to assign role as non-admin user (should fail)\n        # Create a non-admin user and login\n        non_admin_email = f\"student_{uuid.uuid4().hex[:8]}@example.com\"\n        non_admin_password = \"StudentPass123!\"\n        non_admin_id = create_user(admin_token, non_admin_email)\n        try:\n            non_admin_token, _ = get_auth_token(non_admin_email, non_admin_password)\n        except requests.HTTPError:\n            # If direct login disabled for users without confirmation, forcibly set password and confirm\n            # For test, assume success here\n            non_admin_token = None\n\n        if non_admin_token:\n            bad_role_payload = {\"user_id\": user_id, \"role\": \"admin\"}\n            bad_resp = supabase_rest_request(non_admin_token, \"POST\", \"user_roles\", bad_role_payload)\n            # Expect forbidden or unauthorized\n            assert bad_resp.status_code in (401, 403)\n\n        # 7. Permission management: Ensure only admin can modify permissions\n        # Assuming a user_permissions table with user_id and permission columns\n        permission_payload = {\"user_id\": user_id, \"permission\": \"edit_courses\"}\n        perm_resp = supabase_rest_request(admin_token, \"POST\", \"user_permissions\", permission_payload)\n        assert perm_resp.status_code == 201\n        created_perm = perm_resp.json()\n        assert created_perm[0][\"user_id\"] == user_id\n        assert created_perm[0][\"permission\"] == \"edit_courses\"\n\n        # 8. Attempt permission modification as non-admin (should fail)\n        if non_admin_token:\n            bad_perm_payload = {\"user_id\": user_id, \"permission\": \"delete_users\"}\n            bad_perm_resp = supabase_rest_request(non_admin_token, \"POST\", \"user_permissions\", bad_perm_payload)\n            assert bad_perm_resp.status_code in (401, 403)\n\n        # 9. Delete assigned role as admin\n        resp = supabase_rest_request(admin_token, \"DELETE\", f\"user_roles?user_id=eq.{user_id}&role=eq.teacher\")\n        assert resp.status_code == 204\n\n        # 10. Delete assigned permission as admin\n        resp = supabase_rest_request(admin_token, \"DELETE\", f\"user_permissions?user_id=eq.{user_id}&permission=eq.edit_courses\")\n        assert resp.status_code == 204\n\n    finally:\n        # Clean up: Delete created non-admin user if exists\n        if 'non_admin_id' in locals() and non_admin_id:\n            delete_user(admin_token, non_admin_id)\n        # Clean up: Delete created user\n        if user_id:\n            delete_user(admin_token, user_id)\n\ntest_user_management_and_role_assignment()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 76, in test_user_management_and_role_assignment\n  File \"<string>\", line 20, in get_auth_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://pcpiigyuafdzgokiosve.supabase.co/auth/v1/token\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.859Z",
    "modified": "2025-12-16T13:32:31.591Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "12d386f4-e811-4b01-8e13-49fa99a4ddca",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC008-system monitoring access and data retrieval",
    "description": "Validate that system monitoring endpoints are accessible only to admins and super admins and return correct performance analytics and health indicators.",
    "code": "import requests\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nTIMEOUT = 30\nANON_API_KEY = \"your_anon_api_key_here\"\n\n# Sample admin and super admin credentials for authentication\nADMIN_CREDENTIALS = {\n    \"email\": \"admin@example.com\",\n    \"password\": \"AdminPass123!\"\n}\nSUPER_ADMIN_CREDENTIALS = {\n    \"email\": \"superadmin@example.com\",\n    \"password\": \"SuperAdminPass123!\"\n}\nNON_ADMIN_CREDENTIALS = {\n    \"email\": \"teacher@example.com\",\n    \"password\": \"TeacherPass123!\"\n}\n\ndef supabase_auth_signin(email, password):\n    url = f\"{BASE_URL}/auth/v1/token?grant_type=password\"\n    headers = {\"Content-Type\": \"application/json\", \"apikey\": ANON_API_KEY}\n    payload = {\"email\": email, \"password\": password}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef get_system_monitoring_data(jwt_token):\n    url = f\"{BASE_URL}/rest/v1/system_monitoring\"\n    headers = {\n        \"Authorization\": f\"Bearer {jwt_token}\",\n        \"apikey\": ANON_API_KEY,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef test_system_monitoring_access_and_data_retrieval():\n    # Authenticate Admin user\n    admin_auth = supabase_auth_signin(ADMIN_CREDENTIALS[\"email\"], ADMIN_CREDENTIALS[\"password\"])\n    admin_token = admin_auth.get(\"access_token\")\n    assert admin_token is not None, \"Admin authentication failed: no access token returned.\"\n\n    # Authenticate Super Admin user\n    super_admin_auth = supabase_auth_signin(SUPER_ADMIN_CREDENTIALS[\"email\"], SUPER_ADMIN_CREDENTIALS[\"password\"])\n    super_admin_token = super_admin_auth.get(\"access_token\")\n    assert super_admin_token is not None, \"Super Admin authentication failed: no access token returned.\"\n\n    # Authenticate Non-Admin user\n    non_admin_auth = supabase_auth_signin(NON_ADMIN_CREDENTIALS[\"email\"], NON_ADMIN_CREDENTIALS[\"password\"])\n    non_admin_token = non_admin_auth.get(\"access_token\")\n    assert non_admin_token is not None, \"Non Admin authentication failed: no access token returned.\"\n\n    # Admin access to system monitoring endpoint\n    admin_response = get_system_monitoring_data(admin_token)\n    assert admin_response.status_code == 200, f\"Admin should have access. Got status {admin_response.status_code}\"\n    admin_json = admin_response.json()\n    assert isinstance(admin_json, list), \"Admin response should be a JSON list of performance analytics.\"\n    assert len(admin_json) > 0, \"Admin response should contain performance analytics data.\"\n    required_keys = {\"cpu_usage\", \"memory_usage\", \"disk_space\", \"uptime\", \"health_status\"}\n    for item in admin_json:\n        assert required_keys.issubset(item.keys()), \"Admin response missing required health indicator keys.\"\n\n    # Super Admin access to system monitoring endpoint\n    super_admin_response = get_system_monitoring_data(super_admin_token)\n    assert super_admin_response.status_code == 200, f\"Super Admin should have access. Got status {super_admin_response.status_code}\"\n    super_admin_json = super_admin_response.json()\n    assert isinstance(super_admin_json, list), \"Super Admin response should be a JSON list of performance analytics.\"\n    assert len(super_admin_json) > 0, \"Super Admin response should contain performance analytics data.\"\n    for item in super_admin_json:\n        assert required_keys.issubset(item.keys()), \"Super Admin response missing required health indicator keys.\"\n\n    # Non-Admin access to system monitoring endpoint should be forbidden or unauthorized\n    non_admin_response = get_system_monitoring_data(non_admin_token)\n    assert non_admin_response.status_code in (401, 403), f\"Non admin should NOT have access. Got status {non_admin_response.status_code}\"\n\ntest_system_monitoring_access_and_data_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 42, in test_system_monitoring_access_and_data_retrieval\n  File \"<string>\", line 26, in supabase_auth_signin\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://pcpiigyuafdzgokiosve.supabase.co/auth/v1/token?grant_type=password\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.864Z",
    "modified": "2025-12-16T13:32:27.140Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "f0890a31-9a61-48d1-94d0-eb5c5e01cf4e",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC009-session management and token handling",
    "description": "Test session management APIs to ensure secure token storage, auto-refresh functionality, and proper session expiration handling.",
    "code": "import requests\nimport time\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_session_management_and_token_handling():\n    timeout = 30\n    # Use a test user credential (assuming test credentials exist)\n    test_email = \"test.session.user@example.com\"\n    test_password = \"TestPassword123!\"\n\n    # Step 1: Register a new user (if registration requires admin approval, user may be pending)\n    register_payload = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n    try:\n        # Register user (if already exists, ignore error)\n        resp = requests.post(f\"{AUTH_URL}/signup\", json=register_payload, headers=HEADERS, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Registration request failed: {e}\")\n\n    assert resp.status_code in (200, 201, 400), f\"Unexpected registration status code: {resp.status_code}\"\n    # 400 could mean user already exists\n\n    # Step 2: Login the user to get access and refresh tokens\n    login_payload = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n    try:\n        resp = requests.post(f\"{AUTH_URL}/token?grant_type=password\", json=login_payload, headers=HEADERS, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Login request failed: {e}\")\n    assert resp.status_code == 200, f\"Login failed with status: {resp.status_code}\"\n    login_data = resp.json()\n    assert \"access_token\" in login_data, \"Access token missing in login response\"\n    assert \"refresh_token\" in login_data, \"Refresh token missing in login response\"\n    access_token = login_data[\"access_token\"]\n    refresh_token = login_data[\"refresh_token\"]\n\n    auth_headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 3: Validate access token usability by calling a protected endpoint (/rest/v1/users)\n    try:\n        users_resp = requests.get(f\"{BASE_URL}/rest/v1/users?select=id,email\", headers=auth_headers, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Protected endpoint request failed: {e}\")\n    assert users_resp.status_code == 200, f\"Access token not valid for protected endpoint: {users_resp.status_code}\"\n\n    # Step 4: Simulate token expiration by waiting or force refresh (Supabase default expires in 60 min, so simulate by refreshing immediately)\n    # Step 5: Use refresh token to get a new access token\n    refresh_payload = {\n        \"refresh_token\": refresh_token\n    }\n    try:\n        refresh_resp = requests.post(f\"{AUTH_URL}/token?grant_type=refresh_token\", json=refresh_payload, headers=HEADERS, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Token refresh request failed: {e}\")\n    assert refresh_resp.status_code == 200, f\"Refresh token failed with status: {refresh_resp.status_code}\"\n    refresh_data = refresh_resp.json()\n    assert \"access_token\" in refresh_data, \"Access token missing after refresh\"\n    new_access_token = refresh_data[\"access_token\"]\n    new_refresh_token = refresh_data.get(\"refresh_token\", refresh_token)  # Some systems rotate refresh tokens\n\n    # Step 6: Validate new access token works\n    new_auth_headers = {\n        \"Authorization\": f\"Bearer {new_access_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        new_users_resp = requests.get(f\"{BASE_URL}/rest/v1/users?select=id,email\", headers=new_auth_headers, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Protected endpoint request with refreshed token failed: {e}\")\n    assert new_users_resp.status_code == 200, \"New access token not valid for protected endpoint\"\n\n    # Step 7: Test session expiration handling by using an invalidated token (simulate by using an invalid token)\n    invalid_auth_headers = {\n        \"Authorization\": \"Bearer invalid_or_expired_token\",\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        expired_resp = requests.get(f\"{BASE_URL}/rest/v1/users?select=id,email\", headers=invalid_auth_headers, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Expired token request failed: {e}\")\n    # Expect unauthorized error 401 or 403\n    assert expired_resp.status_code in (401, 403), f\"Expired/invalid token accepted with status: {expired_resp.status_code}\"\n\n    # Step 8: Logout user by revoking refresh token (if API supports it)\n    # Supabase allows sign out by deleting the session with the refresh token\n    try:\n        logout_resp = requests.post(f\"{AUTH_URL}/logout\", json={\"refresh_token\": new_refresh_token}, headers=HEADERS, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Logout request failed: {e}\")\n    assert logout_resp.status_code == 204, f\"Logout failed with status: {logout_resp.status_code}\"\n\n    # Step 9: After logout, access token should no longer work\n    try:\n        post_logout_resp = requests.get(f\"{BASE_URL}/rest/v1/users?select=id,email\", headers=new_auth_headers, timeout=timeout)\n    except requests.RequestException as e:\n        raise AssertionError(f\"Post logout request failed: {e}\")\n    # Usually tokens work until expiration, but testing if system invalidates immediately\n    # Accept either unauthorized or success but test expects denial ideally\n    assert post_logout_resp.status_code in (401, 403), f\"Access token still valid after logout with status: {post_logout_resp.status_code}\"\n\ntest_session_management_and_token_handling()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 111, in <module>\n  File \"<string>\", line 25, in test_session_management_and_token_handling\nAssertionError: Unexpected registration status code: 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.870Z",
    "modified": "2025-12-16T13:32:13.659Z"
  },
  {
    "projectId": "41d6ba8b-ea9e-4540-881f-326dac4c5d30",
    "testId": "a3ba1522-38f6-42ba-afb6-5288d604c0eb",
    "userId": "84b8b4a8-30a1-70e0-2bcc-c7d1368a6771",
    "title": "TC010-site content management and theming",
    "description": "Verify APIs for managing landing page content, themes, and site settings including dark/light theme switching and responsive UI components.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://pcpiigyuafdzgokiosve.supabase.co\"\nAUTH_URL = f\"{BASE_URL}/auth/v1\"\nREST_URL = f\"{BASE_URL}/rest/v1\"\nAPI_KEY = \"your-service-role-or-api-key\"  # Replace with valid service role key for testing, or use environment variable\n\nHEADERS = {\n    \"apikey\": API_KEY,\n    \"Authorization\": f\"Bearer {API_KEY}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\nTIMEOUT = 30\n\n\ndef test_site_content_management_and_theming():\n    \"\"\"\n    Test managing landing page content, themes, and site settings including dark/light theme switching\n    and responsive UI components.\n    \"\"\"\n\n    # Supabase RESTful tables assumed: site_contents, site_themes, site_settings\n    # This test will:\n    # - Create landing page content\n    # - Update theme settings (dark/light)\n    # - Get site settings and validate responsive UI components flags\n    # - Cleanup created content and theme entries after test\n\n    content_id = None\n    theme_id = None\n\n    try:\n        # 1. Create landing page content\n        landing_content_payload = {\n            \"title\": \"Test Landing Page\",\n            \"description\": \"Landing page content for testing theming API\",\n            \"content\": \"<h1>Welcome to EDulearn Test</h1>\",\n            \"is_active\": True,\n            \"priority\": 1,  # assuming field for ordering\n        }\n        resp = requests.post(\n            f\"{REST_URL}/site_contents\",\n            headers=HEADERS,\n            json=landing_content_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Landing content creation failed: {resp.text}\"\n        content_data = resp.json()\n        assert isinstance(content_data, list) and len(content_data) == 1, \"Unexpected landing content creation response.\"\n        content_id = content_data[0][\"id\"]\n        assert content_data[0][\"title\"] == landing_content_payload[\"title\"]\n\n        # 2. Create or update theme - set to dark mode\n        theme_payload = {\n            \"theme_name\": \"Test Dark Theme \" + str(uuid.uuid4()),\n            \"mode\": \"dark\",\n            \"primary_color\": \"#121212\",\n            \"secondary_color\": \"#bb86fc\",\n            \"background_color\": \"#000000\",\n            \"font\": \"Roboto\",\n            \"is_active\": True,\n        }\n        # Insert new theme\n        resp = requests.post(\n            f\"{REST_URL}/site_themes\",\n            headers=HEADERS,\n            json=theme_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Theme creation failed: {resp.text}\"\n        theme_data = resp.json()\n        assert isinstance(theme_data, list) and len(theme_data) == 1, \"Unexpected theme creation response.\"\n        theme_id = theme_data[0][\"id\"]\n        assert theme_data[0][\"mode\"] == \"dark\"\n\n        # 3. Switch theme mode to light for the created theme (update)\n        update_payload = {\n            \"mode\": \"light\",\n            \"primary_color\": \"#ffffff\",\n            \"background_color\": \"#f0f0f0\",\n            \"secondary_color\": \"#6200ee\",\n        }\n        resp = requests.patch(\n            f\"{REST_URL}/site_themes?id=eq.{theme_id}\",\n            headers=HEADERS,\n            json=update_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 204, f\"Theme update failed: {resp.text}\"\n\n        # 4. Retrieve and validate updated theme data\n        resp = requests.get(\n            f\"{REST_URL}/site_themes?id=eq.{theme_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Failed to get theme after update: {resp.text}\"\n        theme_records = resp.json()\n        assert len(theme_records) == 1, \"Updated theme record not found.\"\n        theme = theme_records[0]\n        assert theme[\"mode\"] == \"light\"\n        assert theme[\"primary_color\"] == \"#ffffff\"\n\n        # 5. Create or update site settings including responsive UI flags\n        site_settings_payload = {\n            \"site_title\": \"EDulearn Test Site\",\n            \"default_theme_id\": theme_id,\n            \"enable_dark_mode_toggle\": True,\n            \"responsive_ui_enabled\": True,\n            \"updated_at\": \"now()\",  # Assuming DB default or RPC/function\n        }\n        # Upsert site settings by primary key or create new if none exist\n        resp = requests.post(\n            f\"{REST_URL}/site_settings\",\n            headers={**HEADERS, \"Prefer\": \"resolution=merge-duplicates\"},\n            json=site_settings_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code in (201, 200), f\"Site settings creation/upsert failed: {resp.text}\"\n        site_settings_data = resp.json()\n        # site_settings might return list by default\n        assert isinstance(site_settings_data, list) and site_settings_data, \"Unexpected site settings response.\"\n        settings = site_settings_data[0]\n        assert settings[\"enable_dark_mode_toggle\"] is True\n        assert settings[\"responsive_ui_enabled\"] is True\n\n        # 6. Query RPC function for current theme mode switch availability (assuming a RPC exists)\n        rpc_resp = requests.post(\n            f\"{REST_URL}/rpc/can_switch_theme\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        # We expect 200 with boolean result\n        assert rpc_resp.status_code == 200, f\"RPC can_switch_theme failed: {rpc_resp.text}\"\n        rpc_result = rpc_resp.json()\n        assert isinstance(rpc_result, list) and \"can_switch\" in rpc_result[0], \"RPC result format incorrect.\"\n        assert isinstance(rpc_result[0][\"can_switch\"], bool), \"can_switch should be boolean.\"\n\n    finally:\n        # Clean up test data\n        if content_id:\n            requests.delete(\n                f\"{REST_URL}/site_contents?id=eq.{content_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n        if theme_id:\n            requests.delete(\n                f\"{REST_URL}/site_themes?id=eq.{theme_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n\n\ntest_site_content_management_and_theming()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 50, in test_site_content_management_and_theming\nAssertionError: Landing content creation failed: {\"message\":\"Invalid API key\",\"hint\":\"Double check your Supabase `anon` or `service_role` API key.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T13:30:46.876Z",
    "modified": "2025-12-16T13:32:20.232Z"
  }
]
